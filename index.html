<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Asynchronous DOM Modification</title>

    <script>
      console.log("GUI: index.html beginning to run <script>");

      var typing;
      var repl;

      // %js-pump.js includes the build product of %c-pump.js, as well as the
      // emscripten heap, other C code, and emscripten APIs for exchanging
      // data between C and JavaScript.  But note that *all* of that is
      // isolated into the web worker--none of the variables can be directly
      // accessed from the GUI, nor can that code directly access the DOM.
      // The pump is the only way to interact with it.
      //
      // See small helper routine queueEventToC() for posting to the pump.
      //
      var pump = new Worker('js-pump.js'); 

      // We want to start loading the C runtime as soon as possible, and in
      // parallel to loading the DOM content.  But both have to be ready to
      // run useful code.  Wait to send JS_EVENT_DOM_CONTENT_LOADED to the
      // worker until it has sent us JS_EVENT_RUNTIME_INITIALIZED -and- the
      // onDomContentLoaded trigger has happened on the GUI.
      //
      var dom_content_loaded = false;
      var runtime_initialized = false;

      // There is apparently no race condition by setting the onmessage after
      // the pump has already been spawned.  No messages will be lost:
      //
      // https://stackoverflow.com/a/3416386/211160
      //
      pump.onmessage = function(e) {
        id = e.data[0];
        str = e.data[1];

        switch (id) {

        case 'JS_EVENT_RUNTIME_INITIALIZED':
          // This will kick off the C code, so that it can run for a while
          // and then--when it decides to--return a request to the pump to
          // be processed.
          //
          if (dom_content_loaded) // onDomContentLoaded() already happened
              queueEventToC('JS_EVENT_DOM_CONTENT_LOADED');
          else {
              // wait to send event until onDomContentLoaded() happens
          }
          runtime_initialized = true;
          break;

        // Getting a JS_EVENT_XXX signal back from the pump just means that
        // the C code returned from processing that event.  No data is passed
        // back from the C here--it would do that with an ensuing C_REQUEST.
        // 
        case 'JS_EVENT_DOM_CONTENT_LOADED': // startup handled
          repl.innerHTML = "";
        case 'JS_EVENT_OUTPUT_DONE':
        case 'JS_EVENT_GOT_INPUT':
          break;

        case 'C_REQUEST_OUTPUT': {
          repl.innerHTML += str + "<br>";
          queueEventToC('JS_EVENT_OUTPUT_DONE');
          break; }

        case 'C_REQUEST_INPUT': {
          typing.disabled = false;
          typing.style = null;
          break; } // JS_EVENT_GOT_INPUT will be sent later via onTypingEnter()

        case 'C_REQUEST_SLEEP': {
          //
          // !!! Needs way to have requests parameterized with integers, or
          // perhaps always strings will be used?
          //
          alert("C_REQUEST_SLEEP not implemented yet");
          break; }

        case 'C_REQUEST_QUIT': {
          alert("Process called js_exit()");
          break; }

        default: {
          alert(id);
          alert("onRequestFromC(" + id + ") : Unknown Request ID");
          break; }
        }
      }

      function queueEventToC(id, str) { // str `undefined` if not passed in
        if (str === undefined)
          str = null; // although `undefined == null`, canonize to null
        if (id == 'JS_EVENT_DOM_CONTENT_LOADED')
          repl.innerHTML = null;
        pump.postMessage([id, str]); // argument will be e.data in onmessage(e)
      }

      function onTypingEnter() {
        //
        // As a sample visual change we might like to take care of before
        // calling back into C, just disable the typed input.  Turn it gray
        // to make it look disabled, then actually disable it.
        //
        typing.style = "color: grey; background-color: #F0F0F0;"; // looks
        typing.disabled = true; // behavior

        queueEventToC('JS_EVENT_GOT_INPUT', typing.value);
        typing.value = null;
      }

      document.addEventListener('DOMContentLoaded', function () {
        console.log("GUI: DOMContentLoaded event");

        typing = document.getElementById('typing');
        repl = document.getElementById('repl');

        if (runtime_initialized) // runtime initialized first
          queueEventToC('JS_EVENT_DOM_CONTENT_LOADED');
        else {
          // wait to send until JS_EVENT_RUNTIME_INITIALIZED
        }
        dom_content_loaded = true;
      });

      // ESCAPE key requests a halt.  While it would be technically possible
      // to use a custom emterpret() function and just throw away the re-entry
      // allowing escape from even an uncooperative C routine, that could
      // pull the rug out of something that had had just done a malloc().
      // Hence it has to be cooperative and wait for the PG_Halted to be
      // polled, until some deeper magic comes about.
      //
      // https://stackoverflow.com/a/3369743/211160
      //
      document.onkeydown = function(evt) {
        evt = evt || window.event;
        var isEscape = false;
        if ("key" in evt)
          isEscape = (evt.key == "Escape" || evt.key == "Esc");
        else
          isEscape = (evt.keyCode == 27);
        if (isEscape)
          queueEventToC('JS_EVENT_HALTED');
      };
    </script>
  </head>
  <body>
    <div id='repl' style='font-family: monospace;'>
      <b>...loading... (see browser console log for errors)</b>
    </div>
    <input
      type='TEXT'
      id='typing'
      value='abc'
      style='color: grey; background-color: #F0F0F0;'
      disabled=true
      onkeydown='if (event.key === "Enter") onTypingEnter();'
    >
  </body>
</html>
