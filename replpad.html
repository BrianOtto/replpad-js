<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Asynchronous DOM Modification</title>

    <script>
      var typing;
      var prompt;
      var result;

      // %js-pump.js includes the build product of %c-pump.js, as well as the
      // emscripten heap, other C code, and emscripten APIs for exchanging
      // data between C and JavaScript.  But note that *all* of that is
      // isolated into the web worker--none of the variables can be directly
      // accessed.  The pump is the only way to interact with it.
      //
      // See small helper routine queueEventToC() for posting to the pump.
      //
      var pump = new Worker('js-pump.js');

      pump.onmessage = function (e) {
        id = e.data[0];
        str = e.data[1];

        switch (id) {

        // Getting a JS_EVENT_XXX signal back from the pump just means that
        // the C code returned from processing that event.  No data is passed
        // back from the C here--it would do that with an ensuing C_REQUEST.
        // 
        case 'JS_EVENT_DOM_CONTENT_LOADED': // startup handled
          result.innerHTML = "";
        case 'JS_EVENT_OUTPUT_DONE':
        case 'JS_EVENT_GOT_INPUT':
          prompt.innerHTML = "(...running browser events...)";
          break;

        case 'C_REQUEST_OUTPUT': {
          result.innerHTML += "<tt>" + str + "</tt><br>";
          queueEventToC('JS_EVENT_OUTPUT_DONE');
          break; }

        case 'C_REQUEST_INPUT': {
          typing.disabled = false;
          typing.style = null;
          prompt.innerHTML = "Enter a String";
          break; } // JS_EVENT_GOT_INPUT will be sent later via onTypingEnter()

        case 'C_REQUEST_SLEEP': {
          //
          // !!! Needs way to have requests parameterized with integers, or
          // perhaps always strings will be used?
          //
          alert("C_REQUEST_SLEEP not implemented yet");
          break; }

        default: {
          alert(id);
          alert("onRequestFromC(" + id + ") : Unknown Request ID");
          break; }
        }
      }

      function queueEventToC(id, str) { // str `undefined` if not passed in
        if (str === undefined)
            str = null; // although `undefined == null`, canonize to null
        prompt.innerHTML = "(...running C code...)";
        pump.postMessage([id, str]); // argument will be e.data in onmessage(e)
      }

      function onHalt() {
        queueEventToC('JS_EVENT_HALTED');
      }

      function onTypingEnter() {
        //
        // As a sample visual change we might like to take care of before
        // calling back into C, just disable the typed input.  Turn it gray
        // to make it look disabled, then actually disable it.
        //
        typing.style = "color: grey; background-color: #F0F0F0;"; // looks
        typing.disabled = true; // behavior

        queueEventToC('JS_EVENT_GOT_INPUT', typing.value);
      }

      document.addEventListener('DOMContentLoaded', function () {
        typing = document.getElementById('typing');
        prompt = document.getElementById('prompt');
        result = document.getElementById('result');

        // This will kick off the C code, so that it can run for a while
        // and then--when it decides to--return a request to the pump to
        // be processed.
        //
        queueEventToC('JS_EVENT_DOM_CONTENT_LOADED');
      });
    </script>
  </head>
  <body>
    <button onclick="onHalt()">Halt</button>
    <div id='prompt'>Initializing</div>
    <div id='result'><tt><b>(...)</b></tt></div>
    <input
      type='TEXT'
      id='typing'
      value='abc'
      style='color: grey; background-color: #F0F0F0;'
      disabled=true
      onkeydown='if (event.key === "Enter") onTypingEnter();'
    >
  </body>
</html>
